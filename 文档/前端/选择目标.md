# 对象

## 源容器chooseSource

能够被作为选择源的容器，3个状态，优先级排列如下
    choosing：已以该元素为源开始选择，元素会放大
    hovering：移动到该元素上时，元素会放大
    none：空状态
通过暴露的startChoose方法开始进行选择
@onHover，在非选择状态下鼠标移入该元素，修改当前状态为.hovering
@onStop，在选择状态下结束选择时回调，清空当前状态

## 选择链条

存在时即代表当前为选择状态，此时右键可以强制关闭选择状态，并修改选中对象的状态失去.hovering

## 选择框

选择状态下移动到规则对应的选择目标容器时，会选中目标容器对应的target对象
该目标容器覆盖一个选择框

## 目标容器

能够被作为选择目标的容器，4个状态，优先级排列如下
    selectable:在本次选择中为可选目标时，该元素将会出现虚线的灰色选择框
    hovered:在选择状态下移动到该元素上时，该元素将会出现实线的灰色选择框
    selected:在本次选择中已经选中时，该元素将会出现实线的黑色选择框
通过暴露的remove方法将其从场上移除

在选择框存在的情况下左键点击即可选中该目标，目标容器状态为.chosen
如果可以选择多个目标，则原本的选择链条会保留，并创建一根新的选择链条，直到选择目标达到需求

### 状态管理

目标容器会在渲染时，将目标包裹在一层选择状态管理对象中，并将其添加到统一的目标管理api(targetManager.ts)下，该api提供对场上目标的状态修改和查询方法
目标容器使用该状态管理对象来判断target的选择状态，例如
    鼠标移动到可选的目标容器时，会修改isHovered状态=>hovered状态
    鼠标左键点击未选中的可选目标容器时，会修改isSelected状态为true，并触发chooseTagretApi中的选中目标方法
    再次选中已选择的目标，会修改isSelected状态为false

# 选择流程

@onSuccess：成功完成选择

1.选择一个选择来源，并在对应的操作下调用startChoose，要求传入该次选择的targetType和chooseOption
    1.进入选择状态，清空已选目标，固定选择源状态为hovering
    2.并以此为源头产生选择链条
    3.解析传入的目标类型TargetType并通过返回值得到本次选择的规则
        规则内容将会包括：
            1.可选目标的阵营：敌人or玩家or不限
            2.是否为全选
            3.是否为特定的某几个目标为可选
            4.当前场上是否可以直接使用卡牌而不需要选中目标
            5.当前是否没有可选目标
            6.需要进行的选择数量/次数
    4.根据选择规则判断选择框的类型,并设定可选目标
2.在选择状态下移动鼠标，移入可选目标中并左键点击以选择该目标
3.在每次选择后判断是否还需要继续选择(选择数量是否达标)，若不需要继续选择，则完成选择，触发完成回调函数
4.结束选择，离开选择状态，清空已选目标，触发结束选择回调函数
5.在选择过程中右键以取消选择，进入4



