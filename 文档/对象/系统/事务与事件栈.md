# 事务

玩家的一次操作会创建一个“事务”，每个事务都包含一个事件栈。
事务的事件栈中存储着这个操作引发的一系列事件，和这些事件所连锁引发的其他事件。

同一时间只会存在一个事务，在该事务过程中的触发的所有事件都被视作该事务所引发（或所连锁引发）的事件

事务大致分为3个阶段：收集开始，收集结束，结算事务

收集开始：标识着该事务开始收集接下来触发的各个事件，并存放到事件栈中
收集结束：标识着该事务已经完成了事件收集，同时还会整理同一触发级下不同优先级的事件的顺序
结算事务：按触发级和优先级顺序执行该事务的事件栈

# 事件栈

事件栈是一个事务过程中，用于存储各个事件的数据结构。

事件栈的作用包含
1.硬性限制递归，避免递归调用造成严重影响
2.提供一个全局的事件监听接口，用于成就等系统
3.提供上下文接口，用于获取之前或之后的事件，从而实现事件拦截和事件修改

事件栈会按照触发级来存放事件，触发级是指某个事件或效果在连锁触发过程中，其所处的顺序位置，即先触发的事件/效果会先执行

例如：
事务开始，触发事件A => 定义事件A的触发级 = 0
事件A触发了事件B => 事件B的触发级 = 1
事件B触发了事件B1和事件B2（允许这两个事件在不同的对象上）=> 事件B1和事件B2的触发 = 2

## 触发顺序/规则

1.触发级更高的事件更先执行
2.触发级相同的事件，优先级更高的更先执行
3.触发级和优先级都相同的事件，先进入事件栈的先执行

例如：
玩家打出了[打击]卡牌，对敌人造成10点伤害
敌人持有[减伤3]效果，会抵挡3点伤害，同时持有[易伤3]效果，会使得受到的伤害增加25%

打出卡牌行动 => 事务开始收集事件
 => [打击]卡牌会造成10点伤害，收集并宣布事件1：“造成10点伤害”，其触发级为0
 => 敌人接受到事件1的宣布，敌人身上的[减伤3]+[易伤3]触发器被触发
 => [减伤3]会将事件1的效果减少3点，收集并宣布事件2：“减少事件1的效果3点”，其触发级为2
 => [易伤3]会将事件1的效果增加25%，收集并宣布事件3：“增加事件1的效果25%”，其触发级同样为2
 => 没有新的事件触发了，事务结束收集事件
 => 事务开始执行事件栈
 => 事件2和事件3的触发级更高，更先执行

 =>等等，触发时机的问题要如何解决？

## 存放事件

在事务过程中触发的事件都不会被立即执行，而是存入该事务的事件栈中
不过，事件的“触发”依旧会执行，即该事件相关的对象仍然会收到“该事件将会执行”的通知，从而触发其上绑定的其他事件

在存放事件时，会按照事件的触发级来放置事件，同时会为该事件分配栈序号

## 事件栈序号

向事件栈中存放事件时，会为事件分配栈序号

每当开始执行某个事件时，就会将事件栈锁定，直到该事件完成，切换到下一个事件的栈序号。

这是为了防止某些有异步需求的事件打乱事件执行顺序。

## 事件拦截

某个事件可能会触发其他事件/效果将其拦截，使得其无法触发。

这类事件的实现步骤如下：

1.触发一个统一的事件：BlockEvent()，并传入你希望拦截的事件的特征（栈序号或事件关键字）
2.BlockEvent()会在填入事件栈时被特殊处理，从而在事件栈收集结束时，按需搜索事件栈中的事件对象，为其添加“blocked:true,blockedBy:xxx”字段，拥有该字段的事件对象将会被跳过执行效果

### 条件拦截

你可以为BlockEvent的传入拦截条件，从而使得持有拦截字段的事件在被执行时判断当前是否需要拦截该事件

## 事件修改

某个事件a的逻辑部分可能会修改位于其【之后】的某个事件的效果，你可以通过访问事件栈序号/搜索事件关键字来获得位于其【之后】的任意事件对象，从而对其进行修改

* 注意：你只能且只应该修改之后的事件！ *

## 事件添加

某个事件a的逻辑部分可能会添加新的事件，即当事件栈执行到事件a时，再向事件栈中添加新的事件。

这类事件a的实现步骤如下：

1.创建新事件B，向事件栈中添加事件
2.事件栈此时已经结束收集，因此可以特异地将处理这个添加事件过程
3.事件栈会以当前栈序号x寻找到事件a，为新事件B分配栈序号x_1，
4.创建一个新的事件栈，收集新事件B+触发，并得到之后的一系列连锁触发，在收集结束时整理顺序
5.在事件a的结束前1时刻触发上述的独立触发级
6.如果过程1添加了多个事件，则这些事件的栈序号为事件a的栈序号x_n，n为该事件的添加顺序,这些事件在收集到独立的触发级后，会按

* 注意：新添加的事件栈【默认】会继承亲事件栈的剩余栈长度，如果你想实现一些酷炫的超级无敌爆炸连锁效果，你可能需要修改事件栈的设置 *
