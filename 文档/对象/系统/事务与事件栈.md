# 事务

事务是游戏过程中，因玩家的操作而创建的一个事件调度器。
事务用来管理游戏过程中发生的事件，使其1.有序地，2.可预测地，3.可观测地发生。

通常情况下，事务会随着因玩家的操作而创建的第一个事件一同创建，并在之后的所有连锁事件结束时一同结束。

## 事务的执行

游戏中，一次只会执行一个事务，在该事务过程中的触发的所有事件都被该事务所管理
其他的事务会按操作顺序依次放置在操作队列中按顺序执行

例如，玩家连续打出了2张卡牌，这是两个分别的操作，因此会创建两个独立的事务，按操作顺序依次执行。

事务的执行可能会被打断，但更准确地说法是使得在这之后的所有事务都消失，操作也会回滚。

### 事务的执行阶段

事务的执行分为3个阶段：收集，整理，结算

收集：标识着该事务开始收集接下来触发的各个事件，并存放到事件栈中
  每个事件的收集过程如下：
    1.事件A受到触发，被当前事务所捕获
    2.事件A被【宣布】，触发单个事件B
    3.事件B收到触发，被当前事务所捕获，同样宣布事件A
    4.事件B没有触发其他事件，事务中的每个事件都结束了触发，因此事务的收集结束

  *宣布：将某个事件即将发生的信息传递给该事件的参与者，并触发参与者上与该事件有关的其他事件，宣布某个事件并不会触发其效果

整理：事务已经完成了事件收集，开始整理这些事件的顺序，排序规则如下：
  1.触发顺序：事件a使得事件b以before形式触发，这意味着事件b会在事件a之前触发，同理于after
  2.触发优先级：优先级更高的事件更先触发
  3.收集顺序：越先收集的事件更先触发
  

结算：按触发级和优先级顺序执行该事务的事件栈

# 事件栈

事件栈是一个事务过程中，用于存储各个事件的数据结构。

事件栈的作用包含
1.硬性限制递归，避免递归调用造成严重影响
2.提供一个全局的事件监听接口，用于成就等系统
3.提供上下文接口，用于获取之前或之后的事件，从而实现事件拦截和事件修改

事件栈会按照触发级来存放事件，触发级是指某个事件或效果在连锁触发过程中，其所处的顺序位置，即先触发的事件/效果会先执行

例如：
事务开始，触发事件A => 定义事件A的触发级 = 0
事件A触发了事件B => 事件B的触发级 = 1
事件B触发了事件B1和事件B2（允许这两个事件在不同的对象上）=> 事件B1和事件B2的触发 = 2

## 触发顺序/规则

1.触发级更高的事件更先执行
2.触发级相同的事件，优先级更高的更先执行
3.触发级和优先级都相同的事件，先进入事件栈的先执行

例如：
玩家打出了[打击]卡牌，对敌人造成10点伤害
敌人持有[减伤3]效果，会抵挡3点伤害，同时持有[易伤3]效果，会使得受到的伤害增加25%

打出卡牌行动 => 事务开始收集事件
 => [打击]卡牌会造成10点伤害，收集并宣布事件1：“造成10点伤害”，其触发级为0
 => 敌人接受到事件1的宣布，敌人身上的[减伤3]+[易伤3]触发器被触发
 => [减伤3]会将事件1的效果减少3点，收集并宣布事件2：“减少事件1的效果3点”，其触发级为2
 => [易伤3]会将事件1的效果增加25%，收集并宣布事件3：“增加事件1的效果25%”，其触发级同样为2
 => 没有新的事件触发了，事务结束收集事件
 => 事务开始执行事件栈
 => 事件2和事件3的触发级更高，更先执行
 => 事件2和事件3都在触发时获取了事件1，此时可以修改事件1的数值
 => 事件2和事件3依次触发完成后，触发事件1，对敌人造成(10-3)*125%的伤害

 =>等等，触发时机的问题要如何解决？

## 事件栈单位

事件栈由事件栈单位eventUnit构成

## 存放事件

在事务过程中触发的事件并不会被立即执行，而是存入该事务的事件栈中
不过，事件的“触发”依旧会执行，即该事件相关的对象仍然会收到“该事件将会执行”的通知，从而触发其上绑定的其他事件

在存放事件时，会按照事件的触发级来放置事件，同时会为该事件分配栈序号

## 事件栈序号

向事件栈中存放事件时，会为事件分配栈序号

每当开始执行某个事件时，就会将事件栈锁定，直到该事件完成，切换到下一个事件的栈序号。

这是为了防止某些有异步需求的事件打乱事件执行顺序。

## 事件拦截

某个事件可能会触发其他事件/效果将其拦截，使得其无法触发。

这类事件的实现步骤如下：

1.触发一个统一的事件：BlockEvent()，并传入你希望拦截的事件的特征（栈序号或事件关键字）
2.BlockEvent()会在填入事件栈时被特殊处理，从而在事件栈收集结束时，按需搜索事件栈中的事件对象，为其添加“blocked:true,blockedBy:xxx”字段，拥有该字段的事件对象将会被跳过执行效果

### 条件拦截

你可以为BlockEvent的传入拦截条件，从而使得持有拦截字段的事件在被执行时判断当前是否需要拦截该事件

## 事件修改

某个事件a的逻辑部分可能会修改位于其【之后】的某个事件的效果，你可以通过访问事件栈序号/搜索事件关键字来获得位于其【之后】的任意事件对象，从而对其进行修改

* 注意：你只能且只应该修改之后的事件！ *

## 事件添加

某个事件a的逻辑部分可能会添加新的事件，即当事件栈执行到事件a时，再向事件栈中添加新的事件。

这类事件a的实现步骤如下：

1.创建新事件B，向事件栈中添加事件
2.事件栈此时已经结束收集，因此可以特异地将处理这个添加事件过程
3.事件栈会以当前栈序号x寻找到事件a，为新事件B分配栈序号x_1，
4.创建一个新的事件栈，收集新事件B+触发，并得到之后的一系列连锁触发，在收集结束时整理顺序
5.在事件a的结束前1时刻触发上述的独立触发级
6.如果过程1添加了多个事件，则这些事件的栈序号为事件a的栈序号x_n，n为该事件的添加顺序,这些事件在收集到独立的触发级后，会按

* 注意：新添加的事件栈【默认】会继承亲事件栈的剩余栈长度，如果你想实现一些酷炫的超级无敌爆炸连锁效果，你可能需要修改事件栈的设置 *
