# 过程事件 ActionEvent

过程事件是游戏进程中发生了某一件事，以及这件事产生了某些效果的过程
过程事件是一个带有记录性质的对象，其本身并不直接影响游戏进程（造成影响的是各个行为和效果）

作用：
1.统一管理事件的触发与日志
2.用于触发对象的触发器，并且是【唯一一个】调用触发器的接口

## 结构

{   
    key:string,//事件key
    source:Entity,//执行该事件的目标
    medium:Entity,//参与事件的媒介
    target:Entity,//接受该事件的目标
    info:Record<string,any>,//该事件执行全程的信息
    effect?:Effect,//其会携带该事件将会产生的效果，当该事件触发时，这些效果也会发生
}

## 流程

过程事件的完整作用流程
创建：创建过程事件实例，存储该事件相关的各种信息
发生+收集：该过程事件将会发生，发生时，将其收集到当前事务Transaction中
宣布：宣布该过程事件将会发生，等待其他触发器的响应
整理：为事务中的各个过程事件排序
起效：事务整理完毕后，按顺序依次让各个过程事件起效，产生其存储的效果以及可能传入的回调函数

## 过程事件与触发器

过程事件在被宣布时，会令参与事件的各个实体对象的，该事件key的触发器被触发。
理论上，这是你唯一的触发触发器的方法(效果对象也可以触发触发器，但这个过程往往是全自动的)
请尽可能地使用过程事件与实体的触发器交互

<!-- ## 批量事件与子事件

ps:暂时弃用

批量事件是一种独特的事件对象，其本身是一个事件，但其发生的同时，也会收集其包含的各个子事件
你可以理解为其是一个会影响多个对象的事件

批量事件的结构如下

{
    key:string,
    source:Entity,
    medium:Entity,
    target:Entity,
    info:Record<string,any> = [],
    effectUnit:EffectUnit[],
    childEvents:{
        childKey?:string,
        source?:Entity,
        medium?:Entity,
        target?:Entity,
        effectUnit:EffectUnit[]
    }[],
    genericChildKey?:string,//通用子事件key
}

其具备一个事件应有的所有结构，同时还有一个包含了大量可选项的子事件数组。
子事件缺乏的参数会从亲事件中尝试获取，例如没有source的子事件对象会使用亲事件的source，没有childKey的子事件会使用genericChildKey的值

对于其子事件：
    1.不会作为一个单独事件对象在日志中显示
    2.会在亲事件宣布时依次宣布，但不会作为一个单独事件对象被收集/执行
    3.会在亲事件执行时按顺序依次执行 -->

## 方法

triggerEvent("after"|"before")：触发该过程事件的某个时刻的触发器
happen(doEvent:()=>void)：使得该过程事件发生

## 设置

可以对过程事件添加一些设置，从而快速实现一些内置的效果
{
    noTrigger:bool,//该过程事件将不再触发触发器
    stop:bool,//该过程事件将不再发生
}

## 函数

doAction()：创建并发生一个过程事件，用于快速发生某个事件，这也是大部分情况下处理对象效果的所用的函数

doActionGroup()：创建并发生一个过程事件，但还会为其中的每个子对象分别执行一次子事件，s,m,t会各自分别组合进行一次子事件，这些子事件会被包装在总事件中

## 事件堆栈

在开始执行任意一个过程事件时都会向全局的事件堆栈中push该过程事件，随后在触发before=>执行onEvent=>触发after后pop该过程事件

如果pop得到的不是该过程事件，则会报错，因此【禁止随意操作事件堆栈】(或者至少你要明白你的操作过程！)

事件堆栈的作用是获取链式发生的事件，即当事件A的触发/执行导致了事件B的发生时，可以在事件B中获取事件A的信息
如果事件B的执行在事件A的执行之前（事件A触发before=>执行事件B），那么事件B还可以通过操作事件A的信息来修改事件A的执行效果

通过清除事件堆栈，还可以在特定的时机阻止剩余的事件产生效果

通过访问事件堆栈，还可以获知特定的行为/效果的触发顺序，例如可以借此判断回调的过程事件是否在某个事件链上

## 中断事件

如果你希望阻止某个对象上的某个事件发生，则需要为该对象添加事件拦截器
事件拦截器本质上是一个
    1.绑定在指定对象上的(需要指定take,make,on)
    2.该事件key的
    3.优先级最大的
    4.before触发器

当该事件发生时，事件拦截器总是会最先被调用，其会修改事件的设置使得该事件有关的触发器都不会触发，并且不再执行doEvent，在日志中也会打印事件终止的情报

### 中断一个中断事件？

该需求尚未验证……