# 过程事件 ActionEvent

过程事件是游戏进程中发生了某一件事，以及这件事产生了某些效果的过程
过程事件是一个带有记录性质的对象，其本身并不直接影响游戏进程（造成影响的是各个行为和效果）

作用：
1.统一管理事件的触发与日志
2.用于触发对象的触发器，并且是【唯一一个】调用触发器的接口

## 创建

过程事件通常会在两种情况下被创建

## 结构

{   
    key:string,//事件key
    source:Entity,//执行该事件的目标
    medium:Entity,//参与事件的媒介
    target:Entity,//接受该事件的目标
    info:Record<string,any>,//该事件执行全程的信息
    effect?:Effect,//对于一个效果事件，其会携带产生该事件的效果，从而当该事件触发时，可以将该效果提供给新的触发器，以对事件的效果进行修改=>触发堆栈也可以做到这一点，但这样安排更加省事
}

## 过程事件与触发器

过程事件的方法 triggerEvent("before"|"after") 
用于触发参与过程事件的各个对象的触发器
该方法会收集source,medium,target的before或after触发器单元，将其按照level排序，并依次触发
同level下source=>medium=>target的顺序进行触发

一般来说过程事件的使用方法如下：

在某个时刻，即将进行一个事件，这个事件会产生效果a
=>创建过程事件A对象
=>触发事件A的before触发器
=>产生效果a（注意，产生效果a并不依赖过程事件A）
=>触发事件A的after触发器

上述过程可以理应通过过程事件的happen方法简化为
=>创建过程事件A
=>A.happen(doEvent)
注意：如果手动触发效果a，会导致效果a无法被过程事件对象的属性所管理！

这个过程还可以用函数近一步简化（如果你不关心过程事件本身的话）：
=>doAction(传递过程事件所需的参数和回调函数)

## 方法

triggerEvent("after"|"before")：触发该过程事件的某个时刻的触发器
happen(doEvent:()=>void)：使得该过程事件发生，触发before => doEvent() => 触发after

## 设置

可以对过程事件添加一些设置，从而快速实现一些内置的效果
{
    noTrigger:bool,//该过程事件将不再触发触发器
    stop:bool,//该过程事件将不再进行
}

## 函数

doAction()：创建并发生一个过程事件，用于快速发生某个事件，这也是大部分情况下处理对象效果的所用的函数

doActionGroup()：创建并发生一个过程事件，但还会为其中的每个子对象分别执行一次子事件，s,m,t会各自分别组合进行一次子事件，这些子事件会被包装在总事件中

## 事件堆栈

在开始执行任意一个过程事件时都会向全局的事件堆栈中push该过程事件，随后在触发before=>执行onEvent=>触发after后pop该过程事件

如果pop得到的不是该过程事件，则会报错，因此【禁止随意操作事件堆栈】(或者至少你要明白你的操作过程！)

事件堆栈的作用是获取链式发生的事件，即当事件A的触发/执行导致了事件B的发生时，可以在事件B中获取事件A的信息
如果事件B的执行在事件A的执行之前（事件A触发before=>执行事件B），那么事件B还可以通过操作事件A的信息来修改事件A的执行效果

通过清除事件堆栈，还可以在特定的时机阻止剩余的事件产生效果

通过访问事件堆栈，还可以获知特定的行为/效果的触发顺序，例如可以借此判断回调的过程事件是否在某个事件链上

## 中断事件

如果你希望阻止某个对象上的某个事件发生，则需要为该对象添加事件拦截器
事件拦截器本质上是一个
    1.绑定在指定对象上的(需要指定take,make,on)
    2.该事件key的
    3.优先级最大的
    4.before触发器

当该事件发生时，事件拦截器总是会最先被调用，其会修改事件的设置使得该事件有关的触发器都不会触发，并且不再执行doEvent，在日志中也会打印事件终止的情报

### 中断一个中断事件？

该需求尚未验证……