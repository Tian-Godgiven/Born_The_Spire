# 效果Effect

可以这么说，一切会对实体本身产生影响的事件，其都是效果产生的结果。
理论上来讲，我们应该且仅应该通过效果来对实体产生影响。
此外，effect也会触发触发器

## 效果与其他系统

1.过程事件

效果只能由过程事件产生，效果的结果存储在过程事件中

2.触发器

触发器通过在特定时机产生过程事件，从而造成预设的“反馈”效果

3.修饰器

修饰器只能由效果添加，添加时返回“移除回调”也通过效果的“副作用收集器”存储在过程事件中

### 副作用修饰器




# 效果的定义

效果涉及到3个概念，其相互依赖组成游戏的效果Effect系统

## 效果函数 effectFunction

效果函数是效果“起效时”时调用的函数；其接受统一的参数，对设定的目标产生固定的影响，以达到期望的效果，返回可预见的结果；

例如：某个效果能够“造成3点伤害”，那么这个效果对应地会调用“造成伤害”的效果函数;

## 效果对象 Effect

效果对象是在游戏进程中，为系统服务的工具对象，其记录了效果有关的各种信息、参数和效果函数；游戏系统通过处理效果对象→调用效果函数来产生效果

效果对象会被特殊地记录在log日志中
效果对象还会被过程事件所携带，从而在事件过程中被修改，以实现一些独特的与效果交互的效果；

## 效果单元 effectUnit

效果单元是游戏的数据存储在JSON中时表达效果作用的存储型对象；其中包含效果关键字，效果的参数等数据。
某个效果的效果单元结构应当是可预测的（即同一个效果的效果单元应该长成一个样子）

效果对象并不直接存在于游戏中，而是通过效果单元生成的；

例如：卡牌[打击]会“造成6点伤害”，那么这张卡牌的“打出触发器”会携带效果单元“damage（造成伤害）”，该卡牌被打出时会发生一个事件，在这个事件被创建时，系统会根据效果单元同步创建一个效果对象

效果单元是唯一的，且应当是唯一的。一般情况下，我们通过效果关键字寻找指定的效果函数，从而创建效果对象；

通过效果map将效果关键字和效果函数连接起来；

再次梳理一下三者的关系

效果单元--[生成]-->效果对象--[调用]-->效果函数--[关联]-->效果单元

以此为基础我们来梳理一下游戏当中的，系统层面上的效果产生的流程

0.玩家操作
1.实体上的触发器对操作进行反应
2.创建过程事件ActionEvent，其中携带效果单元EffectUnit
3.使用这些效果单元创建效果对象Effect
4.事件收集，并宣布事件和事件携带的效果
5.整理、执行事件
6.应用效果，执行效果函数EffectFun，对实体Entity产生影响

有一点抽象，我们来举一个实例看看

0.玩家打出一张卡牌：【翻滚打击】
1.首先这个操作会创建一个事件1：[打出卡牌：翻滚打击]，事件1是一个操作事件，在这里并不包含效果单元
2.由于此时没有事务，这个事件1的创建还会同时创建一个新事务，并收集+宣布事件1
3.事件1的宣布会触发卡牌对象上的“被打出”触发器
4.这个触发器会创建一个事件2[卡牌效果触发：造成6点伤害，抽一张牌]
5.事件2会包含两个效果单元，在创建事件2的同时，会分别创建两个效果[造成6点伤害]，和[抽一张牌]
6.事件2会被当前事务所收集+宣布，宣布事件2的同时，还会宣布其中的2个效果，即[造成伤害]和[抽牌]
7.我们假设事件2的宣布不会继续触发。则此时事务收集结束，开始整理事件。
8.整理事件完毕后，依次执行事件的效果，对于事件1，其没有效果单元，因此不会特别地执行些什么。对于事件2，其包含两个效果，这两个效果会同步依次执行，调用对应的效果函数，从而对实体产生影响

## mod支持

如果你是一个mod制作者，想要在游戏事件中实现一些酷炫的效果，你可以通过自建效果映射表，并将其添加到系统效果映射表中实现。具体的流程如下

1.制作一个酷炫的效果函数，为其命名(在你的系统内局部唯一即可)
2.创建一个效果名称:效果函数的映射表，将其添加到系统的效果映射表中
3.为你的某个事件添加这个效果名称的效果单元
4.在该事件创建时，会根据这个效果单元创建对应的效果对象，其中就包含了你的酷炫函数
5.在执行事件时，调用效果对象，即可让你的酷炫函数被执行！