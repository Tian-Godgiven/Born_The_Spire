# 效果Effect

可以这么说，一切会对实体本身产生影响的事件，其都是效果产生的结果。
理论上来讲，我们应该且仅应该通过效果来对实体产生影响。
此外，effect也会触发触发器

## 效果与其他系统

1.过程事件

效果只能由过程事件产生，效果的结果存储在过程事件中

2.触发器

触发器通过在特定时机产生过程事件，从而造成预设的“反馈”效果

3.修饰器

修饰器只能由效果添加，添加时返回“移除回调”也通过效果的“副作用收集器”存储在过程事件中

### 副作用修饰器




# 效果的定义

效果涉及到3个概念，其相互依赖组成游戏的效果Effect系统

## 效果函数 effectFunction

效果函数是效果“起效时”时调用的函数；其接受统一的参数，对设定的目标产生固定的影响，以达到期望的效果，返回可预见的结果；

例如：某个效果能够“造成3点伤害”，那么这个效果对应地会调用“造成伤害”的效果函数;

## 效果对象 Effect

效果对象是在游戏进程中，为系统服务的工具对象，其记录了效果有关的各种信息、参数和效果函数；游戏系统通过处理效果对象→调用效果函数来产生效果

效果对象会被特殊地记录在log日志中
效果对象还会被过程事件所携带，从而在事件过程中被修改，以实现一些独特的与效果交互的效果；

## 效果单元 effectUnit

效果单元是游戏的数据存储在JSON中时表达效果作用的存储型对象；其中包含效果关键字，效果的参数等数据。
某个效果的效果单元结构应当是可预测的（即同一个效果的效果单元应该长成一个样子）

效果对象并不直接存在于游戏中，而是通过效果单元生成的；

例如：卡牌[打击]会“造成6点伤害”，那么这张卡牌的“打出触发器”会携带效果单元“damage（造成伤害）”，该卡牌被打出时会发生一个事件，在这个事件被创建时，系统会根据效果单元同步创建一个效果对象

效果单元是唯一的，且应当是唯一的。一般情况下，我们通过效果关键字寻找指定的效果函数，从而创建效果对象；

通过效果map将效果关键字和效果函数连接起来；

再次梳理一下三者的关系

效果单元--[生成]-->效果对象--[调用]-->效果函数--[关联]-->效果单元

以此为基础我们来梳理一下游戏当中的，系统层面上的效果产生的流程

0.玩家操作
1.实体上的触发器对操作进行反应
2.创建过程事件ActionEvent，其中携带效果单元EffectUnit
3.使用这些效果单元创建效果对象Effect
4.事件收集，并宣布事件和事件携带的效果
5.整理、执行事件
6.应用效果，执行效果函数EffectFun，对实体Entity产生影响

有一点抽象，我们来举一个实例看看

0.玩家打出一张卡牌：【翻滚打击】
1.首先这个操作会创建一个事件1：[打出卡牌：翻滚打击]，事件1是一个操作事件，在这里并不包含效果单元
2.由于此时没有事务，这个事件1的创建还会同时创建一个新事务，并收集+宣布事件1
3.事件1的宣布会触发卡牌对象上的“被打出”触发器
4.这个触发器会创建一个事件2[卡牌效果触发：造成6点伤害，抽一张牌]
5.事件2会包含两个效果单元，在创建事件2的同时，会分别创建两个效果[造成6点伤害]，和[抽一张牌]
6.事件2会被当前事务所收集+宣布，宣布事件2的同时，还会宣布其中的2个效果，即[造成伤害]和[抽牌]
7.我们假设事件2的宣布不会继续触发。则此时事务收集结束，开始整理事件。
8.整理事件完毕后，依次执行事件的效果，对于事件1，其没有效果单元，因此不会特别地执行些什么。对于事件2，其包含两个效果，这两个效果会同步依次执行，调用对应的效果函数，从而对实体产生影响

## mod支持

如果你是一个mod制作者，想要在游戏事件中实现一些酷炫的效果，你可以通过自建效果映射表，并将其添加到系统效果映射表中实现。具体的流程如下

1.制作一个酷炫的效果函数，为其命名(在你的系统内局部唯一即可)
2.创建一个效果名称:效果函数的映射表，将其添加到系统的效果映射表中
3.为你的某个事件添加这个效果名称的效果单元
4.在该事件创建时，会根据这个效果单元创建对应的效果对象，其中就包含了你的酷炫函数
5.在执行事件时，调用效果对象，即可让你的酷炫函数被执行！

## params 语法

效果的参数（params）支持动态语法，可以从事件的参与者中获取值。

### 语法规则

```
$<participant>.<type>.<key>
```

**参数说明：**
- `participant`: 事件参与者
  - `source`: 事件来源
  - `medium`: 事件媒介
  - `target`: 事件目标

- `type`: 值的类型
  - `stack`: 状态层数（仅当参与者是 State 对象时可用）
  - `status`: 属性值（从 Status 系统获取）
  - `current`: 当前值（从 Current 系统获取）

- `key`: 具体的键名

### 支持的语法类型

#### 动态值获取：`$<participant>.<type>.<key>`
从事件参与者获取动态值

#### 随机值生成：`$random[min,max]`
生成随机数值
- 整数随机：`$random[1,10]` → 生成 1-10 的整数（包含边界）
- 浮点随机：`$random[1.5,3.5]` → 生成 1.5-3.5 的浮点数（不包含 max）

#### 结果值引用：`$r.<key>`
从事件结果中获取值（旧语法）

### 使用示例

#### 1. 获取状态层数

```typescript
{
  key: "damage",
  params: {
    value: "$source.stack.default"  // 从 source（状态对象）获取 default 层数
  }
}
```

**适用场景：** 中毒状态在回合结束时造成等同于层数的伤害

#### 2. 获取属性值

```typescript
{
  key: "heal",
  params: {
    value: "$target.status.maxHealth"  // 获取目标的最大生命值
  }
}
```

**适用场景：** 完全恢复目标生命值

#### 3. 获取当前值

```typescript
{
  key: "damage",
  params: {
    value: "$target.current.health"  // 获取目标的当前生命值
  }
}
```

**适用场景：** 造成等同于目标当前生命值的伤害

#### 4. 随机值

```typescript
{
  key: "damage",
  params: {
    value: "$random[5,10]"  // 生成 5 到 10 之间的随机整数
  }
}
```

**适用场景：** 造成随机伤害

**语法规则：**
- `$random[min,max]`: 生成随机数
  - 如果 min 和 max 都是整数，生成 [min, max] 范围内的随机整数（包含边界）
  - 如果 min 或 max 有小数，生成 [min, max) 范围内的随机浮点数（不包含 max）
- 示例：
  - `$random[1,6]` → 1, 2, 3, 4, 5, 6（模拟骰子）
  - `$random[5,10]` → 5, 6, 7, 8, 9, 10
  - `$random[1.5,3.5]` → 1.5 到 3.5 之间的浮点数

#### 5. 修改伤害值（状态增伤）

```typescript
// 力量状态：造成伤害时增加伤害
{
  label: "力量",
  key: "power",
  interaction: {
    possess: {
      triggers: [{
        when: "before",
        how: "make",
        key: "damage",
        event: [{
          key: "powerBoost",
          targetType: "triggerEffect",  // 目标是伤害效果本身
          effect: [{
            key: "modifyDamageValue",
            params: {
              delta: "$source.stack.default"  // 增加等同于力量层数的伤害
            }
          }]
        }]
      }]
    }
  }
}
```

### 旧语法：$r.xxx

从事件结果中获取值：

```typescript
{
  key: "someEffect",
  params: {
    value: "$r.resultKey"  // 从 event.getEventResult("resultKey") 获取
  }
}
```

**适用场景：** 当一个效果需要使用前一个效果的返回值时

### 解析时机

参数解析发生在 **Effect 对象构造时**，在 Effect 构造函数中自动调用 `resolveParams()` 方法。

所有以 `$` 开头的字符串参数都会被自动解析为实际值。

**注意：** 随机值每次创建 Effect 对象时都会重新 roll，这意味着同一张卡的不同使用会产生不同的随机值。

### 错误处理

如果解析失败（例如参与者不是预期的类型，或者键不存在），会在控制台输出警告信息，并返回 `undefined`。

效果函数应该妥善处理 `undefined` 值，避免运行时错误。